import type { MutationType } from "../mutations/mutation.interfaces";
import {
  IStoreSchema,
  CollectionNames,
  TDoc,
  DocumentID,
  DateTimeMs,
  arrayOfCollectionNames,
  IDocument,
} from "../interfaces";

import { Observable } from "rxjs";

export type BatchID = number;
export type ClientID = string; // UUID V2

/**
 * V1 `indexeddb` object-stores created by the adapter
 *
 */ export interface IObjectStoresV1 {
  clientInfo: IDBObjectStore /** IClientMetadata */;
  remoteCache: IDBObjectStore /** TDoc */;
  localCache: IDBObjectStore /** TDoc */;
  intercom: IDBObjectStore /** Intercom */;
}

export interface IClientMetadata {
  /**
   * Elliptic Curve Diffe Helman
   * Asymetric key generated by the web crypto api
   *
   * The private key stays with the client, and is non extractable outside indexeddb
   *
   */ cryptoKey: CryptoKey;

  clientID: ClientID;

  /**
   * @param syncRevID sync is based on revision number, and `syncRevID` determines whether the client is in sync with the server
   * client is in sync with server if its `syncRevID` is same as the server. If the client `syncRevID` is lower than the server `syncRevID`
   * then client needs to sync
   *
   * `syncRevID` is assigned and atomically updated by the server during every sync
   *
   */ syncRevID: number;
}

/**
 * A mutation batch needs to be broadcasted to all connected browser tabs
 * The batch is stored temporarily in the intercom and changestream is created using the info
 *
 */ export interface Intercom<
  storeSchema extends IStoreSchema,
  collectionNames extends CollectionNames<storeSchema>,
  doc extends IDocument<storeSchema, collectionNames>
> {
  /**
   * @param batchID Auto-incremented indexeddb primary key representing the mutation batch
   *
   */ batchID: BatchID;

  localTimestamp: DateTimeMs;

  /**
   * @param docIDs Multi-entry indexeddb index containing IDs of all documents in this batch
   *
   */ docIDs: DocumentID[];

  /**
   * @param collectionNames Multi-entry indexeddb index containing collectionNames for docs in this mutation batch
   *
   */ collectionNames: arrayOfCollectionNames<storeSchema, collectionNames>;

  /**
   * @param mutations Documents in this mutation batch
   *
   */ mutations: IMutationRecord<storeSchema, collectionNames, doc>[];
}

/**
 * Defines the shape of a mutation record in the mutation batch
 *
 */ export interface IMutationRecord<
  storeSchema extends IStoreSchema,
  collectionNames extends CollectionNames<storeSchema>,
  doc extends IDocument<storeSchema, collectionNames>
> {
  type: MutationType;
  docID: DocumentID;
  collectionName: collectionNames;

  /**
   * @param doc State of document after the mutation, or null if deleted
   *
   */ doc: TDoc<storeSchema, collectionNames, doc> | null;

  /**
   * @param oldDoc State of document before the mutation
   *
   */ oldDoc: TDoc<storeSchema, collectionNames, doc>;
}

/**
 * Represents a transaction
 *
 */ export interface LMTX {
  store: IObjectStoresV1;
  events$: Observable<Event>;
}
