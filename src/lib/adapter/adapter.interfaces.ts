import ObjectID from "bson-objectid";

export type DocumentID = string;
export type BatchID = number;
export type ClientID = string; // UUID V2
export type DateTimeMs = number;
export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface IClientMetadata {
  /**
   * Elliptic Curve Diffe Helman
   * Asymetric key generated by the web crypto api
   *
   * The key stays with the client, and is non extractable outside indexeddb
   *
   */ cryptoKey: CryptoKey;

  clientID: ClientID;

  /**
   * @param syncRevID sync is based on revision number, and `syncRevID` determines whether the client is in sync with the server
   * client is in sync with server if its `syncRevID` is same as the server. If the client `syncRevID` is lower than the server `syncRevID`
   * then client needs to sync
   *
   * `syncRevID` is assigned and atomically updated by the server during every sync
   *
   */ syncRevID: number;
}

/**
 * Helper that extracts keys from a given interface
 *
 * @template T The interface or type from which we are extracting the keys
 *
 */ export type KnownKeys<T> = {
  [K in keyof T]: string extends K ? never : number extends K ? never : K;
} extends { [_ in keyof T]: infer U }
  ? U
  : never;

/**
 * Schema that defines the interface of all documents in the store
 *
 */ export interface IStoreSchema {
  [collectionName: string]: unknown;
}

/**
 * Extract names of the collections in IStoreSchema
 *
 * @template StoreSchema An interface that extends IStoreSchema
 *
 */ export type CollectionNames<
  StoreSchema extends IStoreSchema
> = StoreSchema extends IStoreSchema ? KnownKeys<StoreSchema> : string;

/**
 * Extract interfaces of the collections in IStoreSchema
 *
 * @template StoreSchema An interface that extends IStoreSchema
 * @template CollectionName Names of the collections to get the interfaces of.
 *
 */ export type TDoc<
  StoreSchema extends IStoreSchema,
  CollectionName extends CollectionNames<StoreSchema>
> = StoreSchema extends IStoreSchema ? StoreSchema[CollectionName] : unknown;

/**
 * @todo Remove this interface this is only a test
 *
 */ export interface Test<StoreSchema extends IStoreSchema> {
  put<Name extends CollectionNames<StoreSchema>>(
    storeName: Name,
    value: TDoc<StoreSchema, Name>
  ): any;
}

/**
 * V1 `indexeddb` object-stores created by the adapter
 *
 */ export interface IObjectStoresV1 {
  clientInfo: IDBObjectStore;
  remoteCache: IDBObjectStore;
  localCache: IDBObjectStore;
  intercom: IDBObjectStore;
}

export interface IDocument<TDoc> {
  /**
   * @param _id BSON ObjectID used by MongoDB as primary key
   * @example
   * ```
   * import { generateDocumentID } from "../../lib";
   * const _id:DocumentID = generateDocumentID()
   * ```
   *
   */ _id: ObjectID;

  /**
   * @param doc Contains the document fields
   *
   */ doc: TDoc;

  /**
   * @param _meta Contains additional metadata populated by the library on every CRUD
   *
   */ _meta: IDocumentMetadata;
}

export interface IDocumentMetadata {
  /**
   * @param id `ObjectID` in a string format
   * @example
   * ```
   * import { generateDocumentID } from "../../lib";
   * const _id:ObjectID = generateDocumentID();
   * const id:DocumentID = _id.str;
   * ```
   *
   */ id: DocumentID;

  /**
   * @param collectionName The collection this document belongs to
   *
   */ collectionName: string;

  createdAt: DateTimeMs;
  lastUpdatedAt: DateTimeMs;
}

/**
 * Docs in remote cache come from the server
 * Server sends relevant documents to client after connection
 * Any local changes made to the remote doc will move that doc from remote to the local cache
 *
 */ export type RemoteCache<TDoc> = IDocument<TDoc>;

/**
 *
 * Clientside CRUD happens in batches, and each batch is treated as an atomic unit.
 * All docs in the batch are created atomically in the same database transaction
 *
 * LocalCache does not keep document revisions for simplicity, hence only the last (final) mutation is recorded
 * and it overwrites the previous mutations, when there are multiple mutations on the same document. Hence, its importaint to merge changes
 * when doing upserts so that the last revision which is stored contains the merged changes from all the mutations before it.
 *
 */ export type LocalCache<TDoc> = IDocument<TDoc>;

/**
 * A mutation batch needs to be broadcasted to all connected browser tabs
 * The batch is stored temporarily in the intercom and changestream is created using the info
 */

export interface Intercom {
  /**
   * @param batchID Auto-incremented indexeddb primary key representing the mutation batch
   *
   */ batchID: BatchID;

  localTimestamp: DateTimeMs;

  /**
   * @param docIDs Multi-entry indexeddb index containing IDs of all documents in this batch
   *
   */ docIDs: DocumentID[];

  /**
   * @param collectionNames Multi-entry indexeddb index containing collectionNames for docs in this mutation batch
   *
   */ collectionNames: string[];

  /**
   * @param mutations Documents in this mutation batch
   *
   */ mutations: IMutationRecord[];
}

export interface IMutationRecord {
  type: MutationType;
  docID: DocumentID;
  collectionName: string;

  /**
   * @param doc State of document after the mutation, or null if deleted
   *
   */ doc: IDocument<unknown> | null;

  /**
   * @param oldDoc State of document before the mutation
   *
   */ oldDoc: IDocument<unknown>;
}
